"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[507],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>g});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),d=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=d(e.components);return i.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=d(n),g=a,u=p["".concat(s,".").concat(g)]||p[g]||c[g]||o;return n?i.createElement(u,r(r({ref:t},m),{},{components:n})):i.createElement(u,r({ref:t},m))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var d=2;d<o;d++)r[d]=n[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5821:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var i=n(3117),a=(n(7294),n(3905));const o={sidebar_position:8,title:"Segmented Mixing Guide"},r=void 0,l={unversionedId:"general/guides/segmented-mixing/segmented-mixing",id:"general/guides/segmented-mixing/segmented-mixing",title:"Segmented Mixing Guide",description:"Introduction and rationale",source:"@site/docs/general/guides/segmented-mixing/segmented-mixing.md",sourceDirName:"general/guides/segmented-mixing",slug:"/general/guides/segmented-mixing/",permalink:"/documentation/docs/general/guides/segmented-mixing/",draft:!1,editUrl:"https://github.com/sequentech/documentation/edit/master/docs/general/guides/segmented-mixing/segmented-mixing.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8,title:"Segmented Mixing Guide"},sidebar:"generalSidebar",previous:{title:"Electoral Board Ceremonies",permalink:"/documentation/docs/general/guides/electoral-board-ceremonies/"},next:{title:"Cron Tasks Guide",permalink:"/documentation/docs/general/guides/cron-tasks/"}},s={},d=[{value:"Introduction and rationale",id:"introduction-and-rationale",level:2},{value:"How does it work",id:"how-does-it-work",level:2},{value:"Implementation details",id:"implementation-details",level:2},{value:"Encoding and decoding segmentation",id:"encoding-and-decoding-segmentation",level:3},{value:"Categories encoding",id:"categories-encoding",level:3},{value:"Producing a segmented tally",id:"producing-a-segmented-tally",level:3},{value:"Risks and limitations",id:"risks-and-limitations",level:2},{value:"How to use it",id:"how-to-use-it",level:2}],m={toc:d};function c(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,i.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"introduction-and-rationale"},"Introduction and rationale"),(0,a.kt)("p",null,"Segmented Mixing allows to speed up election creation and tallying for electoral\nprocesses where you need segmented votes during tallying but the questions being\nvoted are exactly the same in all these segments."),(0,a.kt)("p",null,"The alternative to segmented mixing is using\n",(0,a.kt)("a",{parentName:"p",href:"../parent-and-children-elections/"},"Parent-Children Elections")," with one child\nelection per segment. However, since you need one election per segment and\nelections are tallied sequentially and have a minimum tally (or key-creation)\ntime of around 30 seconds per question in each election, this can slow-down\nthe election creation and the tally time."),(0,a.kt)("p",null,"In contrast, with segmented mixing you only need one election. If you have 30\nsegments (for example provinces), one election with 2 questions and need a tally\nsegmented by province, then a segmented election creation and election tally\nwill take only ~1 minute instead of the 30 minutes it would take for each of\nthose processes with parent-children elections. "),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("a",{parentName:"p",href:"../parent-and-children-elections/"},"Parent-Children Elections")," election is a\nmore generic and powerful mechanism. Use Segmented mixing only when appropriate.")),(0,a.kt)("p",null,"Segmented mixing works by performing a single mix while allowing to\ngroup/segment the resulting anonymized ballots because they have been tagged\nbefore performing the tally."),(0,a.kt)("h2",{id:"how-does-it-work"},"How does it work"),(0,a.kt)("p",null,"Segmented mixing works works as follows:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Each voter has an attribute in the census marking its segmentation. This\ncould be the region of the voter, its category, or any other segmentation\nvariable."),(0,a.kt)("li",{parentName:"ol"},"Before sending the encrypted ballots to the mixnet for shuffling and\ndecryption, the ballots are tagged with a different tag per segment."),(0,a.kt)("li",{parentName:"ol"},"Once the votes are shuffled and decrypted by the mixnet, the raw encoded\nballots are decoded and converted into\n",(0,a.kt)("inlineCode",{parentName:"li"},"(encoded-ballot) -> (region, original-ballot)"),"."),(0,a.kt)("li",{parentName:"ol"},"The ballots are tallied grouped per segment and also showing a consolidated\nresult.")),(0,a.kt)("h2",{id:"implementation-details"},"Implementation details"),(0,a.kt)("p",null,"The encrypted ballots can be tagged by taking advantage of the homomorphic\nproperties of ElGamal encryption, by which we can multiply an encrypted ballot\nwith another encrypted text of a specific number different for each group (the\ntag) and obtain a verifiably encrypted text that contains the result of that\nmultiplication."),(0,a.kt)("p",null,"A encoded plaintext ballot is just an integer number. For example ",(0,a.kt)("inlineCode",{parentName:"p"},"2")," may encode\na vote for ",(0,a.kt)("inlineCode",{parentName:"p"},"Yes")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"4")," may be a vote for ",(0,a.kt)("inlineCode",{parentName:"p"},"No")," in a contest. Take a look at\n",(0,a.kt)("a",{parentName:"p",href:"/documentation/docs/general/reference/ballot-encoding"},"Ballot Encoding")," for more details of how\nwe encode a ballot into a positive integer within Sequent's Voting Platform."),(0,a.kt)("p",null,"ElGamal cryptosystem receives any integer number and produces a ciphertext.\nAn intermediate step before applying ElGamal encryption is to encode this\ninteger plaintext into a multiplicative subgroup ",(0,a.kt)("inlineCode",{parentName:"p"},"Gq")," using the set of quadratic\nresidues modulo ",(0,a.kt)("inlineCode",{parentName:"p"},"p"),". This is required to achieve semantic security. There is a\npost in Sequent's blog detailing this process of\n",(0,a.kt)("a",{parentName:"p",href:"https://sequentech.io/plaintext-encoding-in-elgamal/"},"Elgamal Plaintext encoding"),"."),(0,a.kt)("h3",{id:"encoding-and-decoding-segmentation"},"Encoding and decoding segmentation"),(0,a.kt)("p",null,"Segmentation is performed in the dumping of the ballot box to the mixnet. We\ntake each encrypted ballot ",(0,a.kt)("inlineCode",{parentName:"p"},"E(ballot)")," and multiply with an encrypted category\ntag ",(0,a.kt)("inlineCode",{parentName:"p"},"E(tag)")," resulting in an ciphertext ",(0,a.kt)("inlineCode",{parentName:"p"},"E(ballot * tag)"),". This means that when\ndecrypted, the decryption of such ciphertext will be ",(0,a.kt)("inlineCode",{parentName:"p"},"ballot * tag"),"."),(0,a.kt)("p",null,"For example, if ",(0,a.kt)("inlineCode",{parentName:"p"},"ballot = 4")," (a vote for ",(0,a.kt)("inlineCode",{parentName:"p"},"No"),") and ",(0,a.kt)("inlineCode",{parentName:"p"},"tag = 11")," (category\n",(0,a.kt)("inlineCode",{parentName:"p"},"Madrid"),"), then ",(0,a.kt)("inlineCode",{parentName:"p"},"ballot * tag = 4 * 11 = 44"),". The mixnet will receive ",(0,a.kt)("inlineCode",{parentName:"p"},"E(ballot*tag) = E(44)")," for this ballot instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"E(ballot) = E(4)"),", and the anonymized plaintext of the\nballot, which is part of the mixnet's output, will be ",(0,a.kt)("inlineCode",{parentName:"p"},"44")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"4"),"."),(0,a.kt)("p",null,"Before the tally process can begin, we need to convert back this ",(0,a.kt)("inlineCode",{parentName:"p"},"44")," into ",(0,a.kt)("inlineCode",{parentName:"p"},"4"),",\nbecause otherwise this would be counted as an invalid ballot. At the same time,\nwe need to detect which category does this ballot belong to, to count it only\nfor that category."),(0,a.kt)("p",null,"Categories are encoded as prime numbers, like ",(0,a.kt)("inlineCode",{parentName:"p"},"11")," for ",(0,a.kt)("inlineCode",{parentName:"p"},"category = Madrid"),".\nThus, decoding segmentation is as simple as detecting by which category prime is\nthe segmentation-encoded ballot dividable by. ",(0,a.kt)("inlineCode",{parentName:"p"},"44")," is dividable by ",(0,a.kt)("inlineCode",{parentName:"p"},"11"),", so we\ndetect that it is inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"Madrid")," category, and decoding the\nsegmentation-encoded ballot is as easy as performing ",(0,a.kt)("inlineCode",{parentName:"p"},"44 / 11 = 4"),". We have\nobtained back our ballot plaintext."),(0,a.kt)("h3",{id:"categories-encoding"},"Categories encoding"),(0,a.kt)("p",null,"As mentioned before, each category tag is encoded as a prime number: the\n",(0,a.kt)("strong",{parentName:"p"},"category prime"),". But it has some other constraints - it cannot be any prime\nnumber. For example, the number ",(0,a.kt)("inlineCode",{parentName:"p"},"3")," is prime, but maybe it also could encode a\nvalid ballot, and this could create ambiguous situations in which someone who\nvoted by encoding the ballot ",(0,a.kt)("inlineCode",{parentName:"p"},"3")," and whose category prime is ",(0,a.kt)("inlineCode",{parentName:"p"},"5"),", would be\ninstead assigned the category ",(0,a.kt)("inlineCode",{parentName:"p"},"3")," and the decoded ballot ",(0,a.kt)("inlineCode",{parentName:"p"},"5"),"."),(0,a.kt)("p",null,"For the reason above, a category prime needs to be always bigger than the\nhighest encodable ballot. Additionally, the category prime needs to comply with\nbeing an integer number of the multiplicative subgroup ",(0,a.kt)("inlineCode",{parentName:"p"},"Gq")," by ensuring the\nprime is a quadratic residue modulo ",(0,a.kt)("inlineCode",{parentName:"p"},"p"),", as mentioned earlier."),(0,a.kt)("p",null,"When creating an segmented election, an ordered list possible categories is set.\nAn algorithm calculates the ",(0,a.kt)("inlineCode",{parentName:"p"},"category primes"),", in the given order, assigning a\nprime number for each category tag by simply using the next available integer\nthat complies with the requirements mentioned:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The number is higher than the maximum encodable ballot."),(0,a.kt)("li",{parentName:"ol"},"The number is not in use by any previously calculated category prime."),(0,a.kt)("li",{parentName:"ol"},"The number is prime."),(0,a.kt)("li",{parentName:"ol"},"The number is a quadratic residue modulo ",(0,a.kt)("inlineCode",{parentName:"li"},"p"),".")),(0,a.kt)("h3",{id:"producing-a-segmented-tally"},"Producing a segmented tally"),(0,a.kt)("p",null,"During tallying, the segmentation-encoded plaintext ballots are decoded as\ndescribed in the previous section. However, The whole purpose of the\nsegmentation is to produce segmented election results."),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sequentech/tally-pipes/"},"software module doing the tally"),"\ndetects when an election is segmented, and for each question it duplicates the\nquestion one time per ",(0,a.kt)("a",{parentName:"p",href:"/documentation/docs/general/reference/election-creation-json#election-mixingCategorySegmentation"},"segment"),", and also produce a question with the\naggregated results of all the posible segments."),(0,a.kt)("p",null,"This works in a similar manner to the ",(0,a.kt)("a",{parentName:"p",href:"../parent-and-children-elections/#university-elections-example"},"University elections example")," of the Parent and\nChildren Elections Guide, but in an automatic manner. For example if we have\nonly one question ",(0,a.kt)("inlineCode",{parentName:"p"},"Question 1: What's your favorite color?"),", and we have two\nsegments ",(0,a.kt)("inlineCode",{parentName:"p"},"Madrid")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Sevilla"),", the election results will contain the following\nthree questions:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Question 1: ",(0,a.kt)("inlineCode",{parentName:"li"},"What's your favorite color?"),", containing the results for all\nsegments."),(0,a.kt)("li",{parentName:"ol"},"Question 2: ",(0,a.kt)("inlineCode",{parentName:"li"},"What's your favorite color? - Madrid"),", containing the results\nfor ",(0,a.kt)("inlineCode",{parentName:"li"},"Madrid")," segment of voters."),(0,a.kt)("li",{parentName:"ol"},"Question 3: ",(0,a.kt)("inlineCode",{parentName:"li"},"What's your favorite color? - Sevilla"),", containing the results\nfor ",(0,a.kt)("inlineCode",{parentName:"li"},"Sevilla")," segment of voters.")),(0,a.kt)("h2",{id:"risks-and-limitations"},"Risks and limitations"),(0,a.kt)("p",null,"Segmentation mixing is an advanced feature and has some known risks and\nlimitations. Most importantly, a malicious voter could be able to craft a vote\nin such a manner that this vote will be included in the wrong segmentation\ncategory. However, it's guaranteed by the way segmentation is implemented that\nin this scenario the ballot would always be deemed invalid."),(0,a.kt)("p",null,"Please take the mentioned risks into account before using this feature."),(0,a.kt)("h2",{id:"how-to-use-it"},"How to use it"),(0,a.kt)("p",null,"You need to create an election with:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../../reference/election-creation-json#election-segmentedmixing"},(0,a.kt)("inlineCode",{parentName:"a"},"election.segmentedMixing"))," set to ",(0,a.kt)("inlineCode",{parentName:"li"},"true")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../../reference/election-creation-json#election-mixingCategorySegmentation"},(0,a.kt)("inlineCode",{parentName:"a"},"election.mixingCategorySegmentation")),"\nproperly configured (see the documentation)."),(0,a.kt)("li",{parentName:"ul"},"Have an extra field in the census matching the\n",(0,a.kt)("inlineCode",{parentName:"li"},"election.mixingcategorySegmentation.categoryName"),".")),(0,a.kt)("p",null,"You can find an example election in\n",(0,a.kt)("a",{target:"_blank",href:n(971).Z},"segmented_election.json"),". Here are the\nhighlights:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="segmented_election.json fragment"',title:'"segmented_election.json','fragment"':!0},'{\n   "title": "Segmented election",\n   "segmentedMixing": true,\n   "mixingCategorySegmentation": {\n      "categoryName": "province",\n      "categories": [\n         "Sevilla",\n         "Madrid"\n      ]\n   },\n   "census": {\n      "auth_method": "email",\n      "extra_fields": [\n        {\n          "must": true,\n          "name": "province",\n          "type": "text",\n          "required": true,\n          "private": true,\n          "min": 1,\n          "max": 255,\n          "required_on_authentication": false\n        }\n      ],\n\n... rest of the configution ....\n')),(0,a.kt)("p",null,"Once created the election, it works exactly as a non-segmented election for\nvoters and administrators, except on the election results. Here is how the\nelectoral results look in the dashboard will look like the following:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Election Results in Admin Dashboard",src:n(738).Z,width:"2872",height:"1586"})))}c.isMDXComponent=!0},971:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/files/segmented_election.json-db7f1138d512dc0934fd809888df3f77.yaml"},738:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/segmented-results-dashboard-9f3f119a8c470bf080e0c3c45ae970f6.png"}}]);